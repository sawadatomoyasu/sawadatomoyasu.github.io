<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ストループ課題</title>
  <style>
    :root {
      --bg:#000000;      /* 純粋な黒 */
      --fg:#e8f0fe;
      --muted:#9fb3c8;
      --accent:#6aa9ff;
      --card:#0e1621;
      --border:#1f3248;
    }
    html,body{
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family:-apple-system,BlinkMacSystemFont,"Hiragino Sans","Noto Sans JP",sans-serif;
    }
    .center{min-height:100vh;display:grid;place-items:center;}
    .hidden{display:none!important;}
    #stage{
      display:flex; height:100vh; width:100vw;
      align-items:center; justify-content:center;
    }
    #word{ font-size:clamp(56px,12vw,140px); font-weight:800; }
    #startScreen h1{ font-size:2.8rem; margin-bottom:16px; }
    #startScreen .note{ font-size:1.3rem; line-height:1.7; }
    #startScreen .big-start-hint{
      font-size:2.6rem;
      display:block;
      margin-top:24px;
    }
    #copyTableBtn{
      background:var(--accent); color:#041423; border:none;
      border-radius:12px; font-weight:700; cursor:pointer;
      padding:8px 16px; font-size:14px; margin-right:8px;
    }
    #summaryScreen{ max-width:900px; margin:30px auto; padding:20px; }
    .note{color:var(--muted);font-size:14px;}
    #resultTable{
      width:100%; border-collapse:collapse; margin-top:10px; font-size:14px;
    }
    #resultTable th,#resultTable td{
      border:1px solid var(--border); padding:4px 6px; text-align:center;
    }
    #resultTable th{ background:var(--card); }
  </style>
</head>
<body>

  <!-- 開始画面 -->
  <div id="startScreen" class="center">
    <div style="text-align:center;">
      <h1>ストループ課題</h1>
      <p class="note">
        ●・ひらがな・漢字・カタカナがランダムに呈示されます<br>
        赤色：j，緑色：fキーをできる限り素早く，正確に押してください<br>
        <b class="big-start-hint">スペースキーを押すと課題が始まります</b>
      </p>
    </div>
  </div>

  <!-- 休憩画面 -->
  <div id="breakScreen" class="center hidden">
    <div style="text-align:center;">
      <h1>休憩</h1>
      <p class="note">
        一息ついてください<br>
        <b>スペースキーで次のブロックへ</b>
      </p>
    </div>
  </div>

  <!-- 刺激画面 -->
  <div id="stage" class="hidden">
    <div id="word">+</div>
  </div>

  <!-- 結果画面 -->
  <div id="summaryScreen" class="hidden">
    <h2>課題終了</h2>
    <button id="copyTableBtn">表をコピー</button>

    <table id="resultTable">
      <thead>
        <tr>
          <th>試行数</th>
          <th>刺激種類</th>
          <th>色</th>
          <th>押したキー</th>
          <th>正誤</th>
          <th>一致/不一致</th>
          <th>反応時間（秒）</th>
        </tr>
      </thead>
      <tbody id="resultTableBody"></tbody>
    </table>
  </div>

<script>
const WORD_FORMS = {
  aka:{ meaning:"あか", hiragana:"あか", kanji:"赤", katakana:"アカ" },
  midori:{ meaning:"みどり", hiragana:"みどり", kanji:"緑", katakana:"ミドリ" }
};
const SCRIPTS=["hiragana","kanji","katakana"];
const BLOCK_TYPES=["dot","hiragana","katakana","kanji"];

function shuffle(a){
  const arr=[...a];
  for(let i=arr.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
  return arr;
}
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

function scriptToLabel(s){
  if(s==="dot") return "●";
  if(s==="hiragana") return "ひらがな";
  if(s==="kanji") return "漢字";
  if(s==="katakana") return "カタカナ";
  return "";
}

function buildBlockTrials(blockType){
  const block=[];
  if(blockType==="dot"){
    for(let i=0;i<20;i++)
      block.push({text:"●",script:"dot",meaning:"あか",meaningCode:"aka",ink:"red",congruent:true});
    for(let i=0;i<20;i++)
      block.push({text:"●",script:"dot",meaning:"みどり",meaningCode:"midori",ink:"green",congruent:true});
    return shuffle(block);
  }

  const script = blockType;

  for(let i=0;i<20;i++)
    block.push({text:WORD_FORMS.aka[script],script,meaning:"あか",meaningCode:"aka",ink:"red",congruent:true});

  for(let i=0;i<20;i++)
    block.push({text:WORD_FORMS.aka[script],script,meaning:"あか",meaningCode:"aka",ink:"green",congruent:false});

  for(let i=0;i<20;i++)
    block.push({text:WORD_FORMS.midori[script],script,meaning:"みどり",meaningCode:"midori",ink:"green",congruent:true});

  for(let i=0;i<20;i++)
    block.push({text:WORD_FORMS.midori[script],script,meaning:"みどり",meaningCode:"midori",ink:"red",congruent:false});

  return shuffle(block);
}

const startScreen=document.getElementById("startScreen");
const breakScreen=document.getElementById("breakScreen");
const stage=document.getElementById("stage");
const wordEl=document.getElementById("word");
const summaryScreen=document.getElementById("summaryScreen");
const resultTableBody=document.getElementById("resultTableBody");
const copyTableBtn=document.getElementById("copyTableBtn");

let trials=[], trialIndex=0, awaitingResponse=false;
let trialOnsetTime=0, results=[];
let blockOrder=[], currentBlockIndex=0;

function showStart(){
  startScreen.classList.remove("hidden");
  breakScreen.classList.add("hidden");
  stage.classList.add("hidden");
  summaryScreen.classList.add("hidden");
}
function showStage(){
  startScreen.classList.add("hidden");
  breakScreen.classList.add("hidden");
  summaryScreen.classList.add("hidden");
  stage.classList.remove("hidden");
}
function showBreak(){
  startScreen.classList.add("hidden");
  stage.classList.add("hidden");
  summaryScreen.classList.add("hidden");
  breakScreen.classList.remove("hidden");
}
function showSummary(){
  startScreen.classList.add("hidden");
  stage.classList.add("hidden");
  breakScreen.classList.add("hidden");
  summaryScreen.classList.remove("hidden");
}

async function runTrial(){
  if(trialIndex>=trials.length){
    if(currentBlockIndex < blockOrder.length - 1){
      currentBlockIndex++;
      showBreak();
    }else{
      endExperiment();
    }
    return;
  }

  const trial=trials[trialIndex];
  showStage();
  awaitingResponse=false;

  const fixation = 1000 + Math.random()*1000;
  wordEl.textContent="+";
  wordEl.style.color="#e8f0fe";
  await sleep(fixation);

  wordEl.textContent=trial.text;
  wordEl.style.color=trial.ink;

  awaitingResponse=true;
  trialOnsetTime=performance.now();
}

async function handleResponse(key){
  if(!awaitingResponse) return;

  const now=performance.now();
  const rt=now - trialOnsetTime;
  const trial=trials[trialIndex];

  // 色に基づく正解判定：緑→f, 赤→j
  const correctKey = trial.ink === "green" ? "f" : "j";
  const correct = (key === correctKey);
  const congLabel = trial.congruent ? "一致" : "不一致";

  results.push({
    trial:results.length+1,
    text:trial.text,
    script:trial.script,
    ink:trial.ink,
    responseKey:key,
    correct,
    congruent:congLabel,
    rt:rt
  });

  awaitingResponse=false;

  // フィードバック：白の○×を1秒
  wordEl.style.color = "#ffffff";
  wordEl.textContent = correct ? "○" : "×";
  await sleep(1000);

  trialIndex++;
  runTrial();
}

function endExperiment(){
  showSummary();
  resultTableBody.innerHTML = "";

  for(const r of results){
    const stimType = scriptToLabel(r.script);
    const colorLabel = r.ink==="red"?"赤色":"緑色";
    const rtSec=(r.rt/1000).toFixed(4);

    // ● の行だけ一致/不一致列を "―" にする
    const congDisplay = (r.script === "dot" ? "―" : r.congruent);

    const row=[ r.trial, stimType, colorLabel,
                r.responseKey, r.correct?1:0, congDisplay, rtSec ];
    const tr=document.createElement("tr");
    row.forEach(v=>{
      const td=document.createElement("td");
      td.textContent=v;
      tr.appendChild(td);
    });
    resultTableBody.appendChild(tr);
  }
}

copyTableBtn.addEventListener("click",()=>{
  const rows=document.querySelectorAll("table tr");
  const lines=[];
  rows.forEach(tr=>{
    const cells=[...tr.children].map(td=>td.textContent);
    lines.push(cells.join("\t"));
  });
  navigator.clipboard.writeText(lines.join("\n"));
});

function startExperiment(){
  blockOrder = shuffle(BLOCK_TYPES);
  currentBlockIndex=0;
  results=[];
  startCurrentBlock();
}

function startCurrentBlock(){
  trials = buildBlockTrials(blockOrder[currentBlockIndex]);
  trialIndex=0;
  awaitingResponse=false;
  runTrial();
}

document.addEventListener("keydown",e=>{
  const key=e.key.toLowerCase();
  const startVisible=!startScreen.classList.contains("hidden");
  const breakVisible=!breakScreen.classList.contains("hidden");

  if(startVisible && e.code==="Space"){
    e.preventDefault();
    startExperiment();
    return;
  }

  if(breakVisible && e.code==="Space"){
    e.preventDefault();
    startCurrentBlock();
    return;
  }

  if(key==="f"||key==="j"){
    handleResponse(key);
  }
});

showStart();
</script>
</body>
</html>
